# DeskFlow Development Log - 2026-02-21

**Project**: Coolaw DeskFlow v0.1.0
**Phase**: Sprint 3 Completion + Sprint 4 Testing + Buffer Period

---

## Completed Today

### Sprint 3 - Desktop App + CLI (Completion)

**TypeScript Error Fixes**

Fixed 7 TypeScript compilation errors in the desktop app:

1. `ChatView.tsx` - Wrong relative import paths (`../../stores` -> `../stores`)
   - Root cause: View files are at `src/views/` (1 level deep), not `src/components/layout/` (2 levels)
2. `SkillsView.tsx` - Same path issue (`../../types` -> `../types`)
3. `chatStore.ts` - Unused `StreamChunk` import and `get` parameter removed
4. `useChat.ts` - Unused `setStreaming` destructure removed

**Decision**: Keep the flat `src/views/` structure rather than nesting views deeper. This is cleaner for a desktop app where views are top-level routing targets.

### Sprint 4 - Testing + Integration

**Test Architecture**

Built a 3-tier test structure:

```
tests/
├── conftest.py             # Shared fixtures (mock_brain, mock_memory, etc.)
├── unit/
│   ├── test_core/          # 7 test files
│   ├── test_memory/        # 3 test files
│   ├── test_tools/         # 4 test files
│   ├── test_llm/           # 3 test files
│   ├── test_api/           # 3 test files
│   ├── test_app/           # 1 test file
│   └── test_cli/           # 2 test files
└── integration/
    ├── test_agent_flow.py
    ├── test_memory_roundtrip.py
    └── test_tool_security.py
```

**Key Testing Decisions**:

1. **LLM adapters**: Mocked at the API client level (e.g., `adapter._client.messages.create = AsyncMock(...)`) rather than at the HTTP level. This tests the conversion logic without needing real API keys.

2. **CLI commands**: Used `unittest.mock.patch` to mock Rich prompts (`Prompt.ask`, `Confirm.ask`) and external services (`httpx.AsyncClient`). The Typer `CliRunner` was used for smoke tests but most testing was done by calling functions directly.

3. **FastAPI routes**: Used `TestClient` with mocked `_get_state()` / `_get_agent()` functions to inject mock app state. This avoids starting the real server.

4. **Pydantic Settings quirk**: `patch.object(config, "get_db_path")` fails because Pydantic `BaseSettings` overrides `__delattr__`. Solution: `patch("deskflow.app.AppConfig.get_db_path")` patches at the class level instead.

5. **Coverage exclusions**: Added to `pyproject.toml`:
   - `core/protocols.py` - Protocol definitions are not executable
   - `if TYPE_CHECKING:` blocks
   - Abstract method stubs (`...`)

### Buffer Period - Documentation + Verification

**Documents Generated**:

| Document | Path | Content |
|----------|------|---------|
| README.md | `~/Projects/personal/coolaw-deskflow/README.md` | Full project overview, quick start, architecture |
| API Reference | `docs/api.md` | All endpoints, request/response schemas, rate limiting |
| Developer Guide | `docs/developer-guide.md` | Architecture, development workflow, extension guides |
| Configuration | `docs/configuration.md` | All env vars with types, defaults, validation |
| Test Cases | `vault/.../05-测试用例/test-cases-v1.0.md` | 287 test scenarios with IDs |
| Verification Report | `vault/.../06-验证报告/verification-report-v1.0.md` | 6-phase gate results |

**6-Stage Verification Results**: All PASS

---

## Architecture Decisions

### ADR-001: Protocol-Based Dependency Injection

**Context**: The Agent needs to work with different LLM providers, memory backends, and tool sets.

**Decision**: Use Python `Protocol` classes as interfaces. Components are wired together at startup in `app.py`.

**Rationale**: No framework overhead (unlike dependency-injector), easy to mock in tests, supports structural subtyping.

**Consequences**: Every component must satisfy its Protocol at runtime. Mypy strict mode enforces this at development time.

### ADR-002: SQLite + FTS5 for Memory

**Context**: Need persistent, searchable memory that works locally without external services.

**Decision**: SQLite with FTS5 virtual tables for full-text search, plus an LRU cache (L1) for hot entries.

**Rationale**: Zero-dependency (aiosqlite only), sub-millisecond queries for cached entries, FTS5 provides good search quality for conversational text.

**Consequences**: Limited to single-process access. Future scaling would require migration to PostgreSQL.

### ADR-003: Multi-Level Ranking for Memory Retrieval

**Context**: When retrieving relevant memories, naive keyword matching produces poor results.

**Decision**: Composite score using 4 signals:
- Keyword overlap with query (weight 0.4)
- Importance score (weight 0.25)
- Time decay - exponential decay with 7-day half-life (weight 0.25)
- Access frequency (weight 0.1)

**Rationale**: Balances relevance, importance, recency, and popularity. The time decay ensures old memories fade unless they are important.

### ADR-004: Tauri 2 + React for Desktop

**Context**: Need a cross-platform desktop app with native feel.

**Decision**: Tauri 2 (Rust) for the shell, React 18 + TypeScript for the UI, Zustand for state management.

**Rationale**: Tauri produces smaller binaries than Electron (~10MB vs ~150MB), uses the OS webview, and provides Rust-based security. React was chosen for its ecosystem and developer familiarity.

### ADR-005: Tool Security Sandboxing

**Context**: The agent can execute shell commands and file operations, which is powerful but dangerous.

**Decision**: Three layers of defense:
1. **Blocked command list** - Shell tool blocks `rm -rf`, `mkfs`, `dd`, `shutdown`, etc.
2. **Path sandboxing** - File tool restricts to `DESKFLOW_ALLOWED_PATHS`
3. **Timeout** - All tool executions have a configurable timeout (default 30s)

**Rationale**: Defense in depth. Even if one layer fails, the others provide protection.

---

## Problems Encountered

### Problem 1: Pydantic Settings + patch.object

**Symptom**: `AttributeError: 'AppConfig' object has no attribute 'get_db_path'` when using `patch.object(config, "get_db_path")`.

**Root Cause**: Pydantic `BaseSettings.__delattr__` raises `AttributeError` for non-field attributes, which breaks mock cleanup.

**Solution**: Patch at the class level: `patch("deskflow.app.AppConfig.get_db_path", return_value=...)`.

### Problem 2: Typer Exit vs SystemExit

**Symptom**: Test expected `SystemExit` but got `click.exceptions.Exit`.

**Root Cause**: `typer.Exit(1)` raises `click.exceptions.Exit`, not `SystemExit`.

**Solution**: `pytest.raises((SystemExit, ClickExit))`.

### Problem 3: uvicorn Import Inside Function

**Symptom**: `patch("deskflow.cli.serve.uvicorn")` fails because `uvicorn` is imported inside `serve_command()`.

**Root Cause**: The import happens at call time, so the module-level attribute doesn't exist.

**Solution**: `patch.dict("sys.modules", {"uvicorn": mock_uvicorn})`.

---

## Statistics

| Metric | Value |
|--------|-------|
| Python source files | 56 |
| TypeScript source files | 16 |
| Test files | 24 |
| Total tests | 287 |
| Test coverage | 83.21% |
| Lint errors | 0 |
| Type errors | 0 |
| Security issues | 0 |

---

## Tags

#deskflow #development-log #sprint-3 #sprint-4 #testing #architecture
